import { Events } from '../plugin';
import * as amqplib from 'amqplib';
import { DataType } from '../sec.config';
import { EventEmitter } from 'events';
import { Readable } from 'stream';
import { randomUUID } from 'crypto';
import { Tools } from '@bettercorp/tools/lib/Tools';
import events = require('events');

interface internalEvent<T> {
  data: T;
  resultSuccess: Boolean;
  id: string;
}
/*interface transEAREvent<T> {
  data: T;
  topic: string;
  streamTopic: string;
  plugin: string;
  id: string;
}*/

export class ear extends events.EventEmitter {
  private uSelf!: Events;
  private rabbitQConnectionEARChannel!: amqplib.Channel;
  private rabbitQConnectionEARStreamChannel!: amqplib.Channel;
  private readonly rabbitQConnectionEARChannelKey = "2ar";
  private readonly rabbitQConnectionEARChannelKeyMine = "2kr";
  private readonly rabbitQConnectionEARChannelKeyMineStream = "2skr";
  private readonly maxBufferSize = 10000000;
  private readonly earExchange: any = {
    type: 'direct',
    name: 'better-service2-ear'
  };
  private readonly earExchangeOpts: amqplib.Options.AssertExchange = {
    durable: false,
    //exclusive: true,
    autoDelete: true,
  };
  private readonly earExchangeQueueOpts: amqplib.Options.AssertQueue = {
    durable: false,
    autoDelete: true,
    messageTtl: (60 * 60) * 1000, // 60 minutes
  };
  private readonly earExchangeQueueStreamOpts: amqplib.Options.AssertQueue = {
    durable: false,
    exclusive: true,
    autoDelete: true,
    messageTtl: 60 * 1000, // 1 minute
    expires: (60 * 60) * 1000, // 60 minutes
  };

  private getMyQueueKey(channelKey: string) {
    return `${ channelKey }-${ this.uSelf.myId }`;
  }

  private async setupHandler(myEARQueueKey: string, exName: string, exType: string, exOpts: amqplib.Options.AssertExchange, quOpts: amqplib.Options.AssertQueue, listener: { (msg: amqplib.ConsumeMessage | null): void; }) {
    this.uSelf.log.info(`Open channel (${ myEARQueueKey })`);
    const channel = await this.uSelf.rabbitQConnection.createChannel();
    channel.on("close", () => {
      self.uSelf.log.error(`AMQP channel (${ myEARQueueKey }) close`);
      self.uSelf.log.fatal(`AMQP Error: channel (${ myEARQueueKey }) close`);
    });
    channel.on("error", (err: any) => {
      self.uSelf.log.error(`AMQP channel (${ myEARQueueKey }) error`, err);
      self.uSelf.log.fatal(`AMQP Error: channel (${ myEARQueueKey }) error`, err);
    });
    channel.assertExchange(exName, exType, exOpts);
    channel.prefetch(1);
    this.uSelf.log.info(` - READY: [${ myEARQueueKey }]`);
    await channel.assertQueue(myEARQueueKey, quOpts);
    this.uSelf.log.info(` - LISTEN: [${ myEARQueueKey }] - LISTEN`);
    const self = this;
    channel.consume(myEARQueueKey, listener, { noAck: false });
    this.uSelf.log.info(` - LISTEN: [${ myEARQueueKey }] - LISTENING`);
    return channel;
  }

  async initStreamQueueIfNotInited() {
    const self = this;
    if (!Tools.isNullOrUndefined(self.rabbitQConnectionEARStreamChannel)) return;
    this.rabbitQConnectionEARStreamChannel = await this.setupHandler(this.getMyQueueKey(this.rabbitQConnectionEARChannelKeyMineStream), this.earExchange.name, this.earExchange.type, this.earExchangeOpts, this.earExchangeQueueStreamOpts, (msg: amqplib.ConsumeMessage | null) => {
      if (msg === null) return;
      self.builtInStreamEvents.emit(msg.properties.correlationId, msg);
    });
  }

  async init(uSelf: Events) {
    this.uSelf = uSelf;
    const self = this;
    this.uSelf.log.info(`Ready my events name`);

    this.uSelf.log.info(`Ready my events name - ${ this.earExchange.myResponseName }`);

    this.uSelf.log.info(`Ready internal events`);
    this.builtInEvents = new (EventEmitter as any)();
    this.builtInStreamEvents = new (EventEmitter as any)();
    this.uSelf.log.info(`Ready internal events - COMPLETED`);


    const myEARQueueKey = this.getMyQueueKey(this.rabbitQConnectionEARChannelKeyMine);
    this.rabbitQConnectionEARChannel = await this.setupHandler(myEARQueueKey, this.earExchange.name, this.earExchange.type, this.earExchangeOpts, this.earExchangeQueueOpts, (msg: amqplib.ConsumeMessage | null) => {
      if (msg === null) return;
      let body = msg.content.toString();
      self.rabbitQConnectionEARChannel.ack(msg);
      self.uSelf.log.debug(`[RECEVIED ${ myEARQueueKey }]`);
      const bodyObj = JSON.parse(body) as internalEvent<any>;
      self.builtInEvents.emit(msg.properties.correlationId, bodyObj);
    });
  }

  async onReturnableEvent<ArgsDataType = any, ResolveDataType = any, RejectDataType = any>(callerPluginName: string, pluginName: string, event: string, listener: { (resolve: { (...args: ResolveDataType[]): void; }, reject: { (...args: RejectDataType[]): void; }, data: ArgsDataType): void; }): Promise<void> {
    const self = this;
    self.uSelf.log.info(callerPluginName, ` - LISTEN EAR: [${ self.rabbitQConnectionEARChannelKey }-${ pluginName || callerPluginName }-${ event }]`);

    await self.rabbitQConnectionEARChannel.assertQueue(`${ self.rabbitQConnectionEARChannelKey }-${ pluginName || callerPluginName }-${ event }`, self.earExchangeQueueOpts);
    self.uSelf.log.info(callerPluginName, ` - LISTEN EAR: [${ self.rabbitQConnectionEARChannelKey }-${ pluginName || callerPluginName }-${ event }] - LISTENING`);
    await self.rabbitQConnectionEARChannel.consume(`${ self.rabbitQConnectionEARChannelKey }-${ pluginName || callerPluginName }-${ event }`, (msg: any) => {
      let body = msg.content.toString();
      const bodyObj = JSON.parse(body) as transEAREvent<ArgsDataType>;
      listener((x: any) => {
        self.rabbitQConnectionEARChannel.ack(msg);
        self.uSelf.log.debug(callerPluginName, ` - RETURN OKAY: [${ self.rabbitQConnectionEARChannelKeyMine }-${ pluginName || callerPluginName }-${ event }]`);
        self._emitEventAsync(self.rabbitQConnectionEARChannelKeyMine, self.earExchangeQueue, callerPluginName, bodyObj.plugin, bodyObj.topic, self.rabbitQConnectionEARChannel, {
          data: x,
          id: bodyObj.id,
          resultSuccess: true
        } as internalEvent<ArgsDataType>).then(self.log.debug).catch(self.log.fatal);
      }, (x: any) => {
        self.rabbitQConnectionEARChannel.ack(msg);
        self.uSelf.log.debug(callerPluginName, ` - RETURN ERROR: [${ self.rabbitQConnectionEARChannelKeyMine }-${ pluginName || callerPluginName }-${ event }]`);
        self._emitEventAsync(self.rabbitQConnectionEARChannelKeyMine, self.earExchangeQueue, callerPluginName, bodyObj.plugin, bodyObj.topic, self.rabbitQConnectionEARChannel, {
          data: x,
          id: bodyObj.id,
          resultSuccess: false
        } as internalEvent<ArgsDataType>).then(self.log.debug).catch(self.log.fatal);
      }, bodyObj.data);
    }, { noAck: false });
  };
  emitEventAndReturn<ArgsDataType = any, ReturnDataType = any>(callerPluginName: string, pluginName: string, event: string, data?: ArgsDataType, timeoutSeconds?: number): Promise<ReturnDataType> {
    const self = this;
    this.uSelf.log.debug(callerPluginName, ` - EMIT EAR: [${ self.rabbitQConnectionEARChannelKey }-${ pluginName || callerPluginName }-${ event }]`, data);
    return new Promise((resolve, reject) => {
      const resultKey = `${ randomUUID() }-${ new Date().getTime() }${ Math.random() }`;
      let themStreamKey: string = self.getMyQueueKey(self.rabbitQConnectionEARChannelKeyMineStream);
      let thisStreamKey: string = `${ resultKey }-stream`;
      const xtimeoutSeconds = timeoutSeconds || 10;
      const additionalArgs: any = {
        "$$TIME": new Date().getTime(),
        expiration: (xtimeoutSeconds * 1000) + 5000,
        contentType: DataType[typeof data]
      };
      if (additionalArgs.expiration >= self.earExchangeQueueOpts.messageTtl!) return reject(`TTL CANNOT BE GREATER THAN: ${ self.earExchangeQueueOpts.messageTtl! - 2 }ms`);
      let qArguments: any = JSON.parse(JSON.stringify(self.earExchangeQueue));
      for (let iKey of Object.keys(additionalArgs))
        qArguments[iKey] = additionalArgs[iKey];

      if (data instanceof Readable) {
        self.builtInEvents.on(thisStreamKey + '-', (streamChunk: any) => {

        });
        self.builtInEvents.on(thisStreamKey, (streamEvent: any) => {

        });

        resolveFunc = async (value: ReturnDataType | PromiseLike<ReturnDataType>) => {
          // start transfer of stream
          // value should be the stream endpoint - which is the specific service that picked up this request
        };
      }

      const listener = (dataListener: internalEvent<ReturnDataType>): void | any => {
        if (timeoutTimer === null)
          return this.uSelf.log.debug(callerPluginName, ` - REC EAR TOO LATE: [${ self.rabbitQConnectionEARChannelKey }-${ pluginName || callerPluginName }-${ event }]`, dataListener.resultSuccess ? 'SUCCESS' : 'ERRORED', data);
        this.uSelf.log.debug(callerPluginName, ` - REC EAR: [${ self.rabbitQConnectionEARChannelKey }-${ pluginName || callerPluginName }-${ event }]`, dataListener.resultSuccess ? 'SUCCESS' : 'ERRORED', data);
        clearTimeout(timeoutTimer);
        timeoutTimer = null;
        if (data instanceof Readable) {
          (data as Readable).destroy();
        }
        if (dataListener.resultSuccess)
          resolve(dataListener.data);
        else
          reject(dataListener.data);
      };

      let timeoutTimer: any = setTimeout(() => {
        if (timeoutTimer === null)
          return;
        clearTimeout(timeoutTimer);
        timeoutTimer = null;
        self.builtInEvents.removeListener(resultKey, listener);
        self.uSelf.log.debug(callerPluginName, ` - EMIT AR: [${ self.rabbitQConnectionEARChannelKey }-${ pluginName || callerPluginName }-${ event }-${ resultKey }]`, 'TIMED OUT');
        reject(`NO RESPONSE IN TIME: ${ self.rabbitQConnectionEARChannelKey }-${ pluginName || callerPluginName }/${ resultKey } x${ ((data || {}) as any).timeoutSeconds || 10 }s`);
      }, xtimeoutSeconds * 1000);

      self.builtInEvents.once(resultKey, listener);

      self._emitEventAsync(self.rabbitQConnectionEARChannelKey, self.earExchangeQueue, callerPluginName, pluginName, event, self.rabbitQConnectionEARChannel, {
        id: resultKey,
        data: data,
        plugin: OS.hostname(),
        topic: self.earExchange.myResponseName,
        streamTopic: thisStreamKey
      } as transEAREvent<ArgsDataType>, qArguments, {
        correlationId: resultKey
      }).then(self.log.debug).catch(self.log.fatal);

      self.uSelf.log.debug(callerPluginName, ` - EMIT EAR: [${ self.rabbitQConnectionEARChannelKey }-${ pluginName || callerPluginName }-${ event }-${ resultKey }] - EMITTED`, data);* /;;;;;;;;;
    });
  };

  private async simpleEAR<ArgsDataType = any, ReturnDataType = any>(callerPluginName: string, pluginName: string, event: string, data?: ArgsDataType, timeoutSeconds?: number): Promise<ReturnDataType> {
    const self = this;
    const emitToQueue = `${ self.rabbitQConnectionEARChannelKey }-${ pluginName || callerPluginName }-${ event }`;
    this.uSelf.log.debug(callerPluginName, ` - EMIT EAR: [${ emitToQueue }]`, data);
    return new Promise((resolve, reject) => {
      const checkerTimeoutTime = 5000;
      const resultKey = `${ randomUUID() }-${ new Date().getTime() }${ Math.random() }`;
      const xtimeoutSeconds = timeoutSeconds || 10;
      const xtimeout = (xtimeoutSeconds * 1000);

      let checkerTimeoutTimer: any = null;
      let timeoutTimer: any = null;
      const checkerListener = (): void | any => clearCheckoutTimer;
      const responseListener = (dataListener: internalEvent<ReturnDataType>): void | any => {
        clearCheckoutTimer();
        if (timeoutTimer === null)
          return this.uSelf.log.debug(callerPluginName, ` - REC EAR TOO LATE: [${ emitToQueue }]`, dataListener.resultSuccess ? 'SUCCESS' : 'ERRORED', data);
        clearTimeoutTimer();
        this.uSelf.log.debug(callerPluginName, ` - REC EAR: [${ emitToQueue }]`, dataListener.resultSuccess ? 'SUCCESS' : 'ERRORED', data);
        if (dataListener.resultSuccess)
          resolve(dataListener.data);
        else
          reject(dataListener.data);
      };
      const clearCheckoutTimer = () => {
        if (checkerTimeoutTimer !== null) {
          clearTimeout(checkerTimeoutTimer);
          checkerTimeoutTimer = null;
          self.builtInEvents.removeListener(`${ resultKey }-checkin`, checkerListener);
        }
      };
      const clearTimeoutTimer = () => {
        checkerListener();
        if (timeoutTimer !== null) {
          clearTimeout(timeoutTimer);
          timeoutTimer = null;
          self.builtInEvents.removeListener(resultKey, responseListener);
        }
      };
      timeoutTimer = setTimeout(() => {
        if (timeoutTimer === null)
          return;
        clearTimeoutTimer();
        clearTimeoutTimer();
        self.uSelf.log.debug(callerPluginName, ` - EMIT AR: [${ emitToQueue }-${ resultKey }]`, 'TIMED OUT');
        reject(`NO RESPONSE IN TIME: ${ self.rabbitQConnectionEARChannelKey }-${ pluginName || callerPluginName }/${ resultKey } x${ ((data || {}) as any).timeoutSeconds || 10 }s`);
      }, xtimeout * 1000);

      if (xtimeout > checkerTimeoutTime) {
        self.builtInEvents.once(`${ resultKey }-checkin`, checkerListener);
        checkerTimeoutTimer = setTimeout(() => {
          if (checkerTimeoutTimer === null)
            return;
          clearCheckoutTimer();
          self.uSelf.log.debug(callerPluginName, ` - EMIT AR: [${ emitToQueue }-${ resultKey }]`, 'TIMED OUT');
          reject(`NO RESPONSE IN CHECK TIME: ${ self.rabbitQConnectionEARChannelKey }-${ pluginName || callerPluginName }/${ resultKey } x${ checkerTimeoutTime }ms`);
        }, checkerTimeoutTime);
      }

      self.builtInEvents.once(resultKey, responseListener);

      if (!self.rabbitQConnectionEARChannel.sendToQueue(emitToQueue, Buffer.from(JSON.stringify(data)), {
        correlationId: resultKey,
        contentType: typeof data,
        expiration: xtimeout + 5000,
        appId: this.uSelf.myId
      }))
        throw [`Cannot send msg to queue [${ emitToQueue }]: SIM-EAR`];

      self.uSelf.log.debug(callerPluginName, ` - EMIT EAR: [${ emitToQueue }-${ resultKey }] - EMITTED`, data);
    });
  };

  async handleSender<ArgsDataType = any, ReturnDataType = any>(callerPluginName: string, pluginName: string, event: string, data?: ArgsDataType, timeoutSeconds?: number) {
    const self = this;
    this.uSelf.log.debug(callerPluginName, ` - EMIT EAR: [${ self.rabbitQConnectionEARChannelKey }-${ pluginName || callerPluginName }-${ event }]`, data);
    return new Promise((resolve, reject) => {
      const correlationId = `${ randomUUID() }-${ new Date().getTime() }${ Math.random() }`;
      let listOfEvents: IDictionary<{ (...args: any[]): void; }> = {};
      const clearEvents = () => {
        for (let event of Object.keys(listOfEvents)) {
          this.builtInEvents.off(event, listOfEvents[event]);
          this.builtInStreamEvents.off(event, listOfEvents[event]);
        }
      };
      const addEvent = (event: string, listener: { (...args: any[]): void; }) => {
        listOfEvents[event] = listener;
        this.builtInEvents.once(event, listener);
      };
      if (!(data instanceof Readable)) {
        self.builtInEvents.on(correlationId + '-', (streamChunk: any) => {

        });
        self.builtInEvents.on(correlationId, (streamEvent: any) => {

        });

        resolveFunc = async (value: ReturnDataType | PromiseLike<ReturnDataType>) => {
          // start transfer of stream
          // value should be the stream endpoint - which is the specific service that picked up this request
        };
      }
    });
  }

  async sendStream(streamId: string, themEVKey: string, themStreamKey: string, stream: Readable) {
    const self = this;
    await self.initStreamQueueIfNotInited();
    const emptyBuffer = Buffer.from([]);
    let continueStream = true;
    self.builtInEvents.once(`${ streamId }-end`, () => continueStream = false);
    stream.on('end', () => {
      self.rabbitQConnectionEARChannel.sendToQueue(themEVKey, emptyBuffer, {
        correlationId: `${ streamId }-end`,
        contentType: 'stream',
        expiration: 30000,
        appId: this.uSelf.myId
      });
      self.builtInEvents.emit(`${ streamId }-chunk`);
    });
    self.rabbitQConnectionEARChannel.sendToQueue(themStreamKey, stream.read(self.maxBufferSize), {
      correlationId: streamId,
      contentType: 'stream',
      expiration: 30000,
      appId: this.uSelf.myId
    });
    while (continueStream) {
      await new Promise((r: Function) => {
        self.builtInEvents.once(`${ streamId }-chunk`, () => {
          if (!continueStream) return r();
          if (!self.rabbitQConnectionEARStreamChannel.sendToQueue(themStreamKey, stream.read(self.maxBufferSize), {
            correlationId: streamId,
            contentType: 'stream',
            expiration: 30000,
            appId: this.uSelf.myId
          }))
            throw [`Cannot send msg to queue [${ themStreamKey }]: next-chunk`];
          r();
        });
      });

    }
  }

  async * recevieStream(streamId: string, themEVKey: string) {
    const self = this;
    await self.initStreamQueueIfNotInited();
    const emptyBuffer = Buffer.from([]);
    let continueStream = true;
    self.builtInEvents.once(`${ streamId }-end`, () => {
      continueStream = false;
      self.builtInStreamEvents.emit(streamId, null);
    });
    while (continueStream) {
      if (!self.rabbitQConnectionEARChannel.sendToQueue(themEVKey, emptyBuffer, {
        correlationId: `${ streamId }-chunk`,
        contentType: 'stream',
        expiration: 30000
      }))
        throw [`Cannot send msg to queue [${ themEVKey }]: next-chunk`];
      let valToYield = await (new Promise(r => self.builtInStreamEvents.once(streamId, r)));
      if (valToYield !== null)
        yield valToYield;
    }
    if (!self.rabbitQConnectionEARChannel.sendToQueue(themEVKey, emptyBuffer, {
      correlationId: `${ streamId }-end`,
      contentType: 'stream',
      expiration: 30000
    }))
      throw [`Cannot send msg to queue [${ themEVKey }]: end`];
  }

}